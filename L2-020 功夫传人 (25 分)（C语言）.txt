# 题目
L2-020 功夫传人 (25 分)
一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。

这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第i代传人只能在第i-1代传人中拜1个师傅。我们假设已知祖师爷的功力值为Z，每向下传承一代，就会减弱r%，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。

输入格式：
输入在第一行给出3个正整数，分别是：N（≤10 
5
 ）——整个师门的总人数（于是每个人从0到N−1编号，祖师爷的编号为0）；Z——祖师爷的功力值（不一定是整数，但起码是正数）；r ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有N行，第i行（i=0,⋯,N−1）描述编号为i的人所传的徒弟，格式为：

K 
i
​	
  ID[1] ID[2] ⋯ ID[K 
i
​	
 ]

其中K 
i
​	
 是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。K 
i
​	
 为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。

输出格式：
在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过10 
10
 。

输入样例：
10 18.0 1.00
3 2 3 5
1 9
1 4
1 7
0 7
2 6 1
1 8
0 9
0 4
0 3
输出样例：
404
# 思路
**边输入边设置功力是不行的，因为你不能保证设置一个人的功力时，他的师傅已经设置了，所以可以先将每个人的徒弟和徒弟个数存储起来，然后对所有人统一进行实力设置，这里我采取的方式是从祖师爷开始，对他的徒弟设置实力，然后再对徒弟的徒弟设置，依次设置完成后，在没有徒弟时返回。
另外要注意，这里没有说徒弟最多有多少个，但实际不会超过100个（如果开辟的空间太大，有些测试点会显示内存超限，设置100个已经有测试点占内存三分之二左右了。（博主也是第一次遇到内存超限，说实话，看到的时候有点懵）**
# 代码
~~~·
#include<stdio.h>
double a[100005];//存储每个人的实力
int b[100005][100];//存储每个人的徒弟
int flag[100005]={0}; //存储每个人的徒弟个数 
int d[100005];  //存储得道者的倍数 
double r;
void init(int o);
int main()
{
	int n;
	double z;
	scanf("%d %lf %lf",&n,&z,&r);
	int i,j;
	a[0]=z;
	int k,x;
	int count=0;
	double sum=0;
	for(i=0;i<n;i++){
		scanf("%d",&k);
		flag[i]=k;
		if(k==0){
			int t;
			scanf("%d",&t);
			d[i] =t;		
		}
		count=0;
		for(j=0;j<k;j++){
			scanf("%d",&x);
			b[i][count]=x;
			count++;
		} 
	}
	init(0);//初始化每个人该有的功力
	for(i=0;i<n;i++){  //求得道者的功力和
		if(flag[i]==0){
			sum+=a[i]*d[i];
		}
	} 
	printf("%d",(int)sum);
	return 0;
}
void init(int o )//初始化所有人该有的功力
{
	if(flag[o]==0){
		return;
	}
	int i;
	for(i=0;i<flag[o];i++){
		int f=b[o][i];
		a[f]=a[o]-a[o]*r*0.01;
		init(b[o][i]);
	}
}