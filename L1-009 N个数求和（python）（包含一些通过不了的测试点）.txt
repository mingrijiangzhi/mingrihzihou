# 题目
L1-009 N个数求和 (20 分)
本题的要求很简单，就是求N个数字的和。麻烦的是，这些数字是以有理数分子/分母的形式给出的，你输出的和也必须是有理数的形式。

输入格式：
输入第一行给出一个正整数N（≤100）。随后一行按格式a1/b1 a2/b2 ...给出N个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。

输出格式：
输出上述数字和的最简形式 —— 即将结果写成整数部分 分数部分，其中分数部分写成分子/分母，要求分子小于分母，且它们没有公因子。如果结果的整数部分为0，则只输出分数部分。

输入样例1：
5
2/5 4/15 1/30 -2/60 8/3
输出样例1：
3 1/3
输入样例2：
2
4/3 2/3
输出样例2：
2
输入样例3：
3
1/3 -1/6 1/8
输出样例3：
7/24
# 思路
将需要求和的数存入列表之中，然后对列表表中每两个数求和，因为要表示为分数形式，可以将每一个分数的分子和分母当成一个列表存入另一个大列表中，最后通过通分来进行计算并分别表示分子和分母。
当然，计算时，需要求出最小公倍数来通分求解；并且在保证它为最简形式时还需要求出分子和分母的最大公约数，从而进行相关化简。
**这个题中有一些测试点无法通过时，可尝试以下测试点：
输入样例
1
-50/1000
输出样例
-1/20
输入样例
1
-6/4
输出样例
-1  1/-2
输入样例
2
0/1 0/2 
输出样例
0
输入样例
2
0/1 2/4
输出样例
1/2**
# 代码
```
def yuebei(a,b):
    n=a
    m=b
    if(a<b):
        a,b=b,a
    while b:
        x=a%b
        a=b
        b=x
    z=m*n//a
    return a,z
n=int(input())
x=[str(i) for i in input().split()]
z=[]
for i in x:
    a=i.split('/')
    z.append(a)
for i in range(len(z)):
    if i!=len(z)-1:
        j, k = yuebei(int(z[i][1]),int(z[i+1][1]))
        z[i+1][0]=int(z[i][0])*k//(int(z[i][1]))+int(z[i+1][0])*k//(int(z[i+1][1]))
        z[i + 1][1] = k
sum=0
j,k=yuebei(int(z[len(z) - 1][0]),int(z[len(z)-1][1]))
z[len(z) - 1][0]=int(z[len(z) - 1][0])//j
z[len(z)-1][1]=int(z[len(z)-1][1])//j
if z[len(z) - 1][1] < 0:
    z[len(z) - 1][1]=-z[len(z) - 1][1]
    z[len(z) - 1][0]=-z[len(z) - 1][0]
while z[len(z)-1][0] >= z[len(z)-1][1]:
    sum+=1
    z[len(z) - 1][0]-=z[len(z)-1][1]
while -z[len(z)-1][0] >= z[len(z)-1][1]:
    sum-=1
    z[len(z) - 1][0]+=z[len(z)-1][1]

if sum!=0:
    if z[len(z) - 1][0]!=0:
        print(sum,end=' ')
        print("%d/%d"%(z[len(z) - 1][0],z[len(z)-1][1]),end='')
    else:
        print(sum, end='')
else:
    if z[len(z) - 1][0]!=0:
        print("%d/%d"%(z[len(z) - 1][0],z[len(z)-1][1]),end='')
    else:
        print(sum, end='')
        ```