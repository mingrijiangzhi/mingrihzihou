# 题目
L2-002 链表去重 (25 分)
给定一个带整数键值的链表 L，你需要把其中绝对值重复的键值结点删掉。即对每个键值 K，只有第一个绝对值等于 K 的结点被保留。同时，所有被删除的结点须被保存在另一个链表上。例如给定 L 为 21→-15→-15→-7→15，你需要输出去重后的链表 21→-15→-7，还有被删除的链表 -15→15。

输入格式：
输入在第一行给出 L 的第一个结点的地址和一个正整数 N（≤10 
5
 ，为结点总数）。一个结点的地址是非负的 5 位整数，空地址 NULL 用 −1 来表示。

随后 N 行，每行按以下格式描述一个结点：

地址 键值 下一个结点
其中地址是该结点的地址，键值是绝对值不超过10 
4
 的整数，下一个结点是下个结点的地址。

输出格式：
首先输出去重后的链表，然后输出被删除的链表。每个结点占一行，按输入的格式输出。

输入样例：
00100 5
99999 -7 87654
23854 -15 00000
87654 15 -1
00000 -15 99999
00100 21 23854
输出样例：
00100 21 23854
23854 -15 99999
99999 -7 -1
00000 -15 87654
87654 15 -1
# 思路
**定义五个数组，分别用来：接收对应结点的的值（地址作为下标）、下一个地址（当前地址作为下标）、标记对应值是否重复（值的绝对值作为下标）、存放去重后的链表的结点的地址、存放被去掉的链表的结点的地址。
剩下就很简单了，自由发挥，只需要注意：最后输出的时候，链表的最后一个节点指向为-1，要单独输出；还有输出每一个节点时，因为去重后当前结点的指向需要改变，所以输出指向时直接输出下一个结点的地址即可。**
# 代码
~~~
#include<stdio.h>
#include<math.h>
#define max 100005
int a[max],b[max],c[max]={0},d[max],e[max];
int main()
{
	int ad1,n;
	scanf("%d %d",&ad1,&n);
	int i;
	int f,f1,t;
	int cn=0,cnt=0;
	for(i=0;i<n;i++){
		scanf("%d",&f);
		scanf("%d %d",&a[f],&b[f]);
	}
	f1=ad1;
	while(1){
		t=abs(a[f1]);
		if(c[t]==0){
			c[t]=1;
			d[cn]=f1;
			cn++;
		}else{
			e[cnt]=f1;
			cnt++;
		}
		f1=b[f1];
		if(f1==-1){
			break;
		}
	}
	for(i=0;i<cn-1;i++){
		printf("%05d %d %05d\n",d[i],a[d[i]],d[i+1]);
	}
	printf("%05d %d -1\n",d[i],a[d[i]]);
	if(cnt>0){
		for(i=0;i<cnt-1;i++){
			printf("%05d %d %05d\n",e[i],a[e[i]],e[i+1]);
		}
		printf("%05d %d -1\n",e[i],a[e[i]]);
	}
	return 0;
}
